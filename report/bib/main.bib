
@inproceedings{haas:2017:bringing,
	author = "Andreas Haas and Andreas Rossberg and Derek~L. Schuff and
	        Ben~L. Titzer and Michael Holman and Dan Gohman and
	        Luke Wagner and Alon Zakai and {JF} Bastien",
	title = "Bringing the {Web} Up to Speed with {WebAssembly}",
	booktitle = pldi,
	year = 2017,
	series = {PLDI'17}
}

@inproceedings{flatt:2007:adding,
	author = {Flatt, Matthew and Yu, Gang and Findler, Robert Bruce and Felleisen, Matthias},
	title = {Adding Delimited and Composable Control to a Production Programming Environment},
	booktitle = icfp,
	year = 2007,
	series = {ICFP'07}
}

@inproceedings{baxter:2018:putting,
	title = "Putting in All the Stops: Execution Control for {JavaScript}",
	author = "Samuel Baxter and Rachit Nigam and Joe Gibbs Politz and
	        Shriram Krishnamurthi and Arjun Guha",
	booktitle = pldi,
	year = 2018,
	series = {PLDI'18}
}

@article{sitaram:1990:control,
	author = "Dorai Sitaram and Matthias Felleisen",
	title = "Control Delimiters and Their Hierarchies",
	journal = "{LISP} and Symbolic Computation",
	volume = 3,
	number = 1,
	month = may,
	year = {1990},
	pages = {67--99}
}

@inproceedings{felleisen:1988:the,
	author = {Felleisen, Mattias},
	title = {The Theory and Practice of First-Class Prompts},
	year = 1988,
	booktitle = popl,
	pages = {180-190},
	numpages = {11},
	location = {San Diego, CA, USA},
	series = {POPL'88}
}

@inproceedings{danvy:1990:abstracting,
	author = {Danvy, Olivier and Filinski, Andrzej},
	title = {Abstracting Control},
	year = {1990},
	booktitle = lfp,
	pages = {151-160},
	numpages = {10},
	location = {Nice, France},
	series = {LFP'90}
}
  

@inproceedings{farvardin:2020:from,
	author = {Farvardin, Kavon and Reppy, John},
	title = {From Folklore to Fact: Comparing Implementations of Stacks and Continuations},
	year = {2020},
	booktitle = pldi,
	series = {PLDI'20}
}
  
@misc{wasm:threads,
	howpublished =  {\url{https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md}. Accessed
	               Jul 4 2020},
	title =         {Threading proposal for {WebAssembly}},
	year =          {2020},
}

@misc{wasm:exceptions,
	howpublished =  {\url{https://github.com/WebAssembly/exception-handling/blob/master/proposals/Exceptions.md}. Accessed
	               Jul 4 2020},
	title =         {Exception handling},
	year =          {2020},
}

@misc{wasm:asyncify,
	howpublished =  {\url{https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html}. Accessed
	               Jul 4 2020},
	title =         {Pause and Resume {WebAssembly} with {B}inaryen's {A}syncify},
	author = {Zakai, Alon},
	year =          {2019},
}

@misc{wasm:effects,
	howpublished =  {\url{https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-02-rossberg-continuations.pdf}. Accessed
	               Jul 4 2020},
	title =         {Stacks and Continuations for {W}asm --- Idea Sketch},
	author = {Rossberg, Andreas and Leijen, Daan and Hillerstr\"om, Daniel and Sivaramakrishnan, KC and Pretnar, Matija and Lindley, Sam and Dolan, Stephen},
	year =          {2019},
}

@misc{wasm:c-ray,
	howpublished =  {\url{https://github.com/vkoskiv/c-ray}. Accessed
	               Jul 4 2020},
	title =         {C-Ray},
	year =          {2020},
}

@misc{wasm:electron,
	howpublished =  {\url{https://www.electronjs.org}. Accessed
	               July 5, 2020},
	title =         {Electron},
	year =          {2020},
}

@inproceedings{jangda:2019:not-so-fast,
	title = "Not So Fast: {Analyzing} the Performance of {WebAssembly} vs.\ Native Code",
	author = "Abhinav Jangda and Bobby Powers and Emery Berger and Arjun Guha",
	booktitle = atc,
	year =  2019,
	series = {ATC'19}
}

@inproceedings{paige:2014:compilation,
	author = {Paige, Brooks and Wood, Frank},
	title = {A Compilation Target for Probabilistic Programming Languages},
	year = {2014},
	booktitle = icml,
	series = {ICML'14}
}


@misc{wasm:go-issue-1,
	howpublished =  {\url{https://github.com/golang/go/issues/39620}. Accessed
	               July 5, 2020},
	title =         {misc/{W}asm: long tasks with {Go} {WebAssembly}},
	year =          {2020},
}

@misc{wasm:go-issue-2,
	howpublished =  {\url{https://github.com/golang/go/issues/32591}. Accessed
	               July 5, 2020},
	title =         {syscall/js: performance considerations},
	year =          {2020},
}

@misc{wasm:go-issue-3,
	howpublished =  {\url{https://github.com/golang/go/issues/35256}. Accessed
	               July 5, 2020},
	title =         {runtime: fatal error: self deadlock {WebAssembly}},
	year =          {2020},
}


@misc{wasm:go-issue-4,
	howpublished =  {\url{https://github.com/golang/go/issues/26277}. Accessed
	               July 5, 2020},
	title =         {{W}asm: 3x performance overhead of using {WebAssembly} in {N}ode 8},
	year =          {2020},
}


@misc{wasm:racket-generator,
	howpublished =  {\url{https://github.com/racket/racket/blob/ac4ae9ebba653c76edb2bb1f08ec1007427e5333/racket/collects/racket/generator.rkt\#L30}. Accessed July 5, 2020},
	title =         {generator.rkt},
	year =          {2020},
}

@misc{wasm:spec,
	howpublished =  {\url{https://webassembly.github.io/spec/core/}. Accessed Jul 6 2020},
	title =         {{WebAssembly} Specification},
	year =          {2020},
}

@misc{wasm:coq,
	howpublished =  {\url{https://www.cs.rit.edu/~mtf/student-resources/20191_huang_mscourse.pdf}. Accessed Jul 7 2020},
	title =         {A Mechanized Formalization of the {WebAssembly} Specification in {C}oq},
	year =          {2020},
	author = {Huang, Xuan},
}

@inproceedings{watt:2018:mechanising,
	author = {Watt, Conrad},
	title = {Mechanising and Verifying the WebAssembly 	Specification},
	year = {2018},
	booktitle = cpp,
	series = {CPP'18}
}

@inproceedings{watt:2019:weakening,
	author = {Watt, Conrad and Rossberg, Andreas and Pichon-Pharabod, Jean},
	title = {Weakening WebAssembly},
	year = {2019},
	booktitle = oopsla,
	series = {OOPSLA'19}
}


@inproceedings{wasm:R5RS,
	author = {Adams, N. I. and Bartley, D. H. and Brooks, G. and Dybvig, R. K. and Friedman, D. P. and Halstead, R. and Hanson, C. and Haynes, C. T. and Kohlbecker, E. and Oxley, D. and Pitman, K. M. and Rozas, G. J. and Steele, G. L. and Sussman, G. J. and Wand, M. and Abelson, H.},
	title = {{Revised$^5$} Report on the Algorithmic Language Scheme},
	year = {1998},
	booktitle = hosc,
	series = {HOSC'98}
}
  
@inproceedings{pettyjohn:cm,
	title = "Continuations from generalized stack inspection",
	author = "Greg Pettyjohn and John Clements and Joe Marshall and
	        Shriram Krishnamurthi and Matthias Felleisen",
	booktitle = icfp,
	year = {2005},
	series = {ICFP'05}
}

@misc{wasm:lua-vm-wasm,
	howpublished =  {\url{https://github.com/vvanders/wasm_lua}. Accessed
	               Sept 6, 2020},
	title =         {wasm\_lua},
	year =          {2020},
}

@inproceedings{wasm:WARDuino,
	author = {Gurdeep Singh, Robbert and Scholliers, Christophe},
	title = {WARDuino: A Dynamic WebAssembly Virtual Machine for Programming Microcontrollers},
	year = {2019},
	booktitle = mplr,
	series = {MPLR'2019}
}

@misc{pinckney:arxiv-wasmk,
  author = "Donald Pinckney and Arjun Guha and Yuriy Brun",
  title = "Wasm/k: Delimited Continuations for WebAssembly",
  url = "https://arxiv.org/abs/2010.01723",
  year = 2020
}


@inproceedings{baldini:trilemma,
  author =        {Ioana Baldini and Perry Cheng and Stephen~J. Fink and
                   Nick Mitchell and Vinod Muthusamy and Rodric Rabbah and
                   Philippe Suter and Olivier Tardieu},
  booktitle =     {ACM SIGPLAN International Symposium on New Ideas, New
                   Paradigms, and Reflections on Programming and
                   Software (Onward!)},
  title =         {The Serverless Trilemma: Function Composition for
                   Serverless Computing},
  year =          {2017},
}

@article{hughes:arrows,
  author =        {John Hughes},
  journal =       {Science of Computer Programming},
  month =         may,
  number =        {1--3},
  pages =         {67--111},
  title =         {Generalising Monads to Arrows},
  volume =        {37},
  year =          {2000},
}

@inproceedings{nilsson:afrp,
author = {Nilsson, Henrik and Courtney, Antony and Peterson, John},
title = {Functional Reactive Programming, Continued},
year = {2002},
isbn = {1581136056},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/581690.581695},
doi = {10.1145/581690.581695},
abstract = {Functional Reactive Programming (FRP) extends a host programming language with a notion
of time flow. Arrowized FRP (AFRP) is a version of FRP embedded in Haskell based on
the arrow combinators. AFRP is a powerful synchronous dataflow programming language
with hybrid modeling capabilities, combining advanced synchronous dataflow features
with the higher-order lazy functional abstractions of Haskell. In this paper, we describe
the AFRP programming style and our Haskell-based implementation. Of particular interest
are the AFRP combinators that support dynamic collections and continuation-based switching.
We show how these combinators can be used to express systems with an evolving structure
that are difficult to model in more traditional dataflow languages.},
booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell},
pages = {51â€“64},
numpages = {14},
keywords = {synchronous dataflow languages, Haskell, hybrid modeling, domain-specific languages, functional programming, FRP},
location = {Pittsburgh, Pennsylvania},
series = {Haskell '02}
}

@article{jangda:lambda-lambda,
author = {Jangda, Abhinav and Pinckney, Donald and Brun, Yuriy and Guha, Arjun},
title = {Formal Foundations of Serverless Computing},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360575},
doi = {10.1145/3360575},
abstract = {Serverless computing (also known as functions as a service) is a new cloud computing
abstraction that makes it easier to write robust, large-scale web services. In serverless
computing, programmers write what are called serverless functions, which are programs
that respond to external events. When demand for the serverless function spikes, the
platform automatically allocates additional hardware and manages load-balancing; when
demand falls, the platform silently deallocates idle resources; and when the platform
detects a failure, it transparently retries affected requests. In 2014, Amazon Web
Services introduced the first serverless platform, AWS Lambda, and similar abstractions
are now available on all major cloud computing platforms. Unfortunately, the serverless
computing abstraction exposes several low-level operational details that make it hard
for programmers to write and reason about their code. This paper sheds light on this
problem by presenting Î»Î», an operational semantics of the essence of serverless computing.
Despite being a small (half a page) core calculus, Î»Î» models all the low-level details
that serverless functions can observe. To show that Î»Î» is useful, we present three
applications. First, to ease reasoning about code, we present a simplified naive semantics
of serverless execution and precisely characterize when the naive semantics and Î»Î»
coincide. Second, we augment Î»Î» with a key-value store to allow reasoning about stateful
serverless functions. Third, since a handful of serverless platforms support serverless
function composition, we show how to extend Î»Î» with a composition language and show
that our implementation can outperform prior work.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {149},
numpages = {26},
keywords = {serverless computing, formal language semantics, distributed computing}
}


@inproceedings{chong:swift,
author = {Chong, Stephen and Liu, Jed and Myers, Andrew C. and Qi, Xin and Vikram, K. and Zheng, Lantian and Zheng, Xin},
title = {Secure Web Applications via Automatic Partitioning},
year = {2007},
isbn = {9781595935915},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1294261.1294265},
doi = {10.1145/1294261.1294265},
abstract = {Swift is a new, principled approach to building web applications that are secure by
construction. In modern web applications, some application functionality is usually
implemented as client-side code written in JavaScript. Moving code and data to the
client can create security vulnerabilities, but currently there are no good methods
for deciding when it is secure to do so. Swift automatically partitions application
code while providing assurance that the resulting placement is secure and efficient.
Application code is written as Java-like code annotated with information flow policies
that specify the confidentiality and integrity of web application information. The
compiler uses these policies to automatically partition the program into JavaScript
code running in the browser, and Java code running on the server. To improve interactive
performance, code and data are placed on the client side. However, security-critical
code and data are always placed on the server. Code and data can also be replicated
across the client and server, to obtain both security and performance. A max-flow
algorithm is used to place code and data in a way that minimizes client-server communication.},
booktitle = {Proceedings of Twenty-First ACM SIGOPS Symposium on Operating Systems Principles},
pages = {31â€“44},
numpages = {14},
keywords = {security policies, compilers, information flow},
location = {Stevenson, Washington, USA},
series = {SOSP '07}
}



@article{10.1145/1639949.1640091,
author = {Meyerovich, Leo A. and Guha, Arjun and Baskin, Jacob and Cooper, Gregory H. and Greenberg, Michael and Bromfield, Aleks and Krishnamurthi, Shriram},
title = {Flapjax: A Programming Language for Ajax Applications},
year = {2009},
issue_date = {October 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1639949.1640091},
doi = {10.1145/1639949.1640091},
abstract = {This paper presents Flapjax, a language designed for contemporary Web applications.
These applications communicate with servers and have rich, interactive interfaces.
Flapjax provides two key features that simplify writing these applications. First,
it provides event streams, a uniform abstraction for communication within a program
as well as with external Web services. Second, the language itself is reactive: it
automatically tracks data dependencies and propagates updates along those dataflows.
This allows developers to write reactive interfaces in a declarative and compositional
style.Flapjax is built on top of JavaScript. It runs on unmodified browsers and readily
interoperates with existing JavaScript code. It is usable as either a programming
language (that is compiled to JavaScript) or as a JavaScript library, and is designed
for both uses. This paper presents the language, its design decisions, and illustrative
examples drawn from several working Flapjax applications.},
journal = {SIGPLAN Not.},
month = oct,
pages = {1â€“20},
numpages = {20},
keywords = {javascript, web programming, functional reactive programming}
}

@inproceedings{flapjax,
author = {Meyerovich, Leo A. and Guha, Arjun and Baskin, Jacob and Cooper, Gregory H. and Greenberg, Michael and Bromfield, Aleks and Krishnamurthi, Shriram},
title = {Flapjax: A Programming Language for Ajax Applications},
year = {2009},
isbn = {9781605587660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1640089.1640091},
doi = {10.1145/1640089.1640091},
abstract = {This paper presents Flapjax, a language designed for contemporary Web applications.
These applications communicate with servers and have rich, interactive interfaces.
Flapjax provides two key features that simplify writing these applications. First,
it provides event streams, a uniform abstraction for communication within a program
as well as with external Web services. Second, the language itself is reactive: it
automatically tracks data dependencies and propagates updates along those dataflows.
This allows developers to write reactive interfaces in a declarative and compositional
style.Flapjax is built on top of JavaScript. It runs on unmodified browsers and readily
interoperates with existing JavaScript code. It is usable as either a programming
language (that is compiled to JavaScript) or as a JavaScript library, and is designed
for both uses. This paper presents the language, its design decisions, and illustrative
examples drawn from several working Flapjax applications.},
booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
pages = {1â€“20},
numpages = {20},
keywords = {web programming, javascript, functional reactive programming},
location = {Orlando, Florida, USA},
series = {OOPSLA '09}
}


